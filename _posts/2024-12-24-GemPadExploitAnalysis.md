---
layout: post
title: GemPad Exploit Analysis
date: 2024-12-24 10:58 +0900
categories: [analysis]
tags: [exploit, GemPad]
image: /assets/images/gemPadLogo.png
---

On December 17, 2024, GemPad suffered a total loss of $1.8M due to reentrancy vulnerabilities on the Ethereum, BNB, and Base networks.

The details of the GemPad hacking incident are as follows:

The main factors behind the hacking incident are the lack of reentrancy protection and the presence of code that allows arbitrary Uniswap tokens to be deposited and earn interest. This vulnerability enabled a reentrancy attack, allowing the attacker to withdraw the deposited tokens twice.

``` solidity
    function multipleLock(
        address[] calldata owners,
        address token,
        bool isLpToken,
        uint256[] calldata amounts,
        uint40 unlockDate,
        string memory description,
        string memory metaData,
        address projectToken,
        address referrer
    ) external payable override returns (uint256[] memory) {
        _payFee(projectToken, false, isLpToken);       
        return
            _multipleLock(
                owners,
                amounts,
                token,
                isLpToken,
                [unlockDate, 0, 0, 0],
                description,
                metaData,
                projectToken,
                referrer
            );
    }
```

The multipleLock function allows for the deposit of either Uniswap tokens or regular tokens. If Uniswap tokens are deposited, it provides a function to easily collect fees associated with those tokens.

``` solidity
    function collectFees(
        uint256 lockId
    ) external isLockOwner(lockId) validLockLPv3(lockId) returns (uint256 amount0, uint256 amount1) {
        Lock storage userLock = _locks[lockId];
        // set amount0Max and amount1Max to uint256.max to collect all fees
        // alternatively can set recipient to msg.sender and avoid another transaction in `sendToOwner`
        INonfungiblePositionManager.CollectParams
            memory params = INonfungiblePositionManager.CollectParams({
                tokenId: userLock.nftId,
                recipient: address(this),
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            });
        // send collected feed back to owner
        (
            ,
            ,
            address token0,
            address token1,
            ,
            ,
            ,
            ,
            ,
            ,
            ,

        ) = INonfungiblePositionManager(userLock.nftManager).positions(
                userLock.nftId
            );
        uint256 originalAmount0 = IERC20(token0).balanceOf(address(this));
        uint256 originalAmount1 = IERC20(token1).balanceOf(address(this));
        INonfungiblePositionManager(userLock.nftManager).collect(params);
        amount0 = IERC20(token0).balanceOf(address(this)) - originalAmount0;
        amount1 = IERC20(token1).balanceOf(address(this)) - originalAmount1;
        IERC20(token0).safeTransfer(userLock.owner, amount0);
        IERC20(token1).safeTransfer(userLock.owner, amount1);
    }
```

The collectFees function is used to obtain fees for tokens deposited in Uniswap. It calls the collect function of the Uniswap contract and transfers the acquired fees to the deposit owner.

``` solidity
    /// @inheritdoc IUniswapV3PoolActions
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external override lock returns (uint128 amount0, uint128 amount1) {
        // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}
        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);

        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;
        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;

        if (amount0 > 0) {
            position.tokensOwed0 -= amount0;
            TransferHelper.safeTransfer(token0, recipient, amount0);
        }
        if (amount1 > 0) {
            position.tokensOwed1 -= amount1;
            TransferHelper.safeTransfer(token1, recipient, amount1);
        }

        emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);
    }
```

The collect function of Uniswap can call arbitrary token transfer functions, which allows for a reentrancy attack to be carried out.

The attack scenario for the hacking incident is as follows:

1. The attacker creates a custom token and sets up a Uniswap pool for it.

2. Using a flash loan, the attacker supplies liquidity to the Uniswap pool created in step 1.

3. The attacker deposits the Uniswap pool tokens created in step 1 into GemPad.

4. The attacker executes the collect function of GemPad, which triggers the collect function of the Uniswap pool. During the execution of the Uniswap pool's collect function, the custom token's transfer code is designed to redeposit tokens into GemPad, making it appear as though fees were legitimately acquired during the execution of GemPad's collect function.

5. After step 4 concludes, the attacker withdraws the deposited tokens. However, since the deposit records remain, the attacker can withdraw tokens again, effectively double-claiming them.

![img-description](/assets/images/gemPad.png)


# References

[GemPad exploit reentrancy transaction](https://app.blocksec.com/explorer/tx/eth/0x31851d894249339d2d9319141e37219b3e03a99f8b483d47758c1e5ea143cca4)

[GemPad exploit unlock transaction](https://app.blocksec.com/explorer/tx/eth/0x2bb6d2ca3b52a01ff9ec01c931f68762ded9a05693ea65d911a20602eea02763)
